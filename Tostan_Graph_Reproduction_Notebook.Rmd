---
title: "Tostan MERL Graph Reproduction"
output:
  pdf_document: default
  html_notebook: default
---

TODO
make a village type conversion csv?
```{r}
allC <- read.csv("EF_4Pays.csv", na.strings = '---', check.names=FALSE)
village_types <- aggregate(allC$STATUVILL, list(allC$fixture_localization.village), mean)
colnames(village_types) <- c("village","village_type")
village_types$village_type <-as.factor(village_types$village_type)
levels(village_types$village_type) <- c("beneficiary", "adopted","control")
write.csv(village_types, file = "village_types.csv", row.names = FALSE)
```
Now I need to get one large data frame to use from the distinct country/period csv files.
```{r}
Mali <- read.csv("17 02 21 MALI_EF CG3_Questionnaire individuel-v2.csv", na.strings = '---', check.names=FALSE)
Mali_unc <- read.csv("17 02 21 MALI_EF CG3_Questionnaire individuel-v2.csv", na.strings = '---', check.names=FALSE)
Mauri <- read.csv("17 02 21 MAUR_EF CG3_Questionnaire individuel-v2.csv", na.strings = '---', check.names=FALSE)
source("clean_names.R")
names(Mali) <- clean_names(Mali)
names(Mauri) <- clean_names(Mauri)
Mali$country <- "Mali"
Mauri$country <- "Mauritania"
Mali$period <- "EF"
Mauri$period <- "EF"
total <- rbind(Mali, Mauri)
head(total$interviewer)
```

now to figure out how to do calculations on this stuff!
```{r}
# maybe first filter, then calculate? (then store?)
library(dplyr)
filtered <- filter(total, interviewer=="participant", nombre_denfants>0) # same as total[interviewer==participant & nombre_denfants > 0]
grouped <- group_by(total, country, period)
result <- summarize(grouped,
                    tot_under_one = sum(child_under_one_declared, na.rm=TRUE),
                    tot_one_to_five = sum(child_between_1_and_5_declared, na.rm=TRUE),
                    tot_kids = sum(nombre_denfants, na.rm=TRUE),
                    percent_declared = (tot_under_one + tot_one_to_five) / tot_kids
)
result      
#total$percent_voted <- with(total,sum(child_under_one_declared[interviewer=="participant"], na.rm=TRUE))
#k1 <- sum(EF_data$child_under_one_declared[EF_data$interviewer=="participant"], na.rm=TRUE)
#k2 <- sum(EF_data$child_between_1_and_5_declared[EF_data$interviewer=="participant"], na.rm=TRUE)
#total_kids <- sum(EF_data$nombre_denfants[EF_data$interviewer=="participant"], na.rm=TRUE)
```

This is an R Notebook to help reproduce graphs frequently made by MERL, using example data from Guinea.

R notebooks are a combination of code (in the grey boxes, called chunks) and surrounding text explanations. You can run the code for each chunk individually, making the graphs easily reproducible and reusable with new data.

First, let's read in the data we want.
```{r}
getwd()
```

```{r}
d <- read.csv("Forms.csv", na.strings = '---', check.names=FALSE)
EF_data <- read.csv("17-02-21-GB_EF_CG3_Questionnaire individuel-v2.csv", na.strings = '---', check.names=FALSE)
```

Unfortunately, the variable names from the server are not very compatible with R. This code fixes the variable names.
```{r}
source("clean_names.R")
names(d) <- clean_names(d)
names(EF_data) <- clean_names(EF_data)
```

We can visually check and see that the variable names look right by looking at the first few varibles visually.
```{r}
head(names(d),10)
```

Hopefully, those variable names now look good. Next, we can make some graphs!

Now trying to get the data into the proper format for the graph below
```{r}
d$country <- "Gambia"
head(d$country,10)
```

```{r}
registered_girls <- sum(d$GOUV4_nbre_fille_enregistre, na.rm=TRUE)
registered_boys <- sum(d$GOUV5_nbre_garcon_enregistre, na.rm=TRUE)
total_kids <- sum(d$nombre_denfants, na.rm=TRUE)
EB_perc <- (registered_boys + registered_girls) / total_kids
EB_perc
table(d$interviewer[d$nombre_denfants>0])
```
```{r}
k1 <- sum(EF_data$child_under_one_declared[EF_data$interviewer=="participant"], na.rm=TRUE)
k2 <- sum(EF_data$child_between_1_and_5_declared[EF_data$interviewer=="participant"], na.rm=TRUE)
total_kids <- sum(EF_data$nombre_denfants[EF_data$interviewer=="participant"], na.rm=TRUE)
EF_perc <- (k1+k2) / total_kids
table(EF_data$interviewer[EF_data$nombre_denfants>0])
```
```{r}
country <- c('GB','GB','GB','SEN','SEN','SEN')
interviewer <- c('simple','adoptee','participant','simple','adoptee','participant')
period <- c('EB','EF','EF','EB','EF','EF')
percentage_declared <- c(.5,.5,.4,.3,.6,.2)
x <- data.frame(country, interviewer, period, percentage_declared)
blah <-ftable(xtabs(percentage_declared ~ country+period+interviewer, data = x))
library(gridExtra)
grid.table(blah)
```

```{r}
#barplot(as.matrix(x), main="Title", xlab="Phase", ylab="Percentage", names.arg=c("EB","EF","EF"),
#beside = TRUE)
#legend("topright", c("First","Second","third"), cex=1.3, bty="n")
```
Okay to do things with lots of factors it looks like lattice is a good choice. Explanations I liked are
https://www.statmethods.net/advgraphs/trellis.html for basic plot organization
https://magesblog.com/post/2012-12-04-changing-colours-and-legends-in-lattice/ for styling

```{r}
library(RColorBrewer)
myColours <- brewer.pal(4,"Blues")

my.settings <- list(
  superpose.polygon=list(col=myColours[2:4], border="transparent"),
  strip.background=list(col=myColours[1]),
  strip.border=list(col="black")
)

library(lattice) 
barchart(percentage_declared*100~period|country,
         groups=interviewer,data=x,
         ylim=c(0,100),
         ylab = "Percentage Declared",
         main = "Title Here",
        auto.key=list(space="bottom", columns=3, title="District", cex.title=1),
        par.settings = my.settings
        )
```


